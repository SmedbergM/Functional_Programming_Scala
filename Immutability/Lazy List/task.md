## Lazy List

A lazy list in Scala is a collection that evaluates its elements lazily: each element is computed only once, 
the first time it is needed, and then stored for subsequent access. 
Lazy lists can be infinite: their elements are computed on-demand, so if your program keeps accessing the next one 
in an infinite loop, the lazy list will grow until the program fails with an out-of-memory error. 
In practice, however, you will almost always need only a finite number of elements —
it might just be a large number that you don't know from the start — and since the lazy list will compute only values 
that are explicitly requested, it allows developers to work with large datasets or sequences in a memory-efficient manner. 
In such cases, a lazy list provides a convenient method to implement the logic for computing the consecutive elements 
until you decide it is enough. 
You can use it in some specific cases where, otherwise, you would need to code an elaborate data structure with mutable fields
and a method that would compute new values for those fields.


Below is an example of how to generate a Fibonacci sequence using a lazy list in Scala:

```
lazy val fib: LazyList[BigInt] =
  BigInt(0) #::
    BigInt(1) #::
    fib.zip(fib.tail).map { case (a, b) => a + b }

// Fetch and print the first 10 Fibonacci numbers
fib.take(10).foreach(println)
```

In the above code:
* `#::` is an operator that creates a new lazy list with a specified head (the element in front of the operator)
  and a tail (a lazy list after the operator). 
  We start with `BigInt(0)` being the head, and the expression after `#::` being the tail. 
  Now, the tail, again, consists of a head (`BigInt(1)`) and a tail connected with the `#::` operator. 
  That second, "internal", so to say, tail, is constructed with the `zip` method operating on the original lazy list, `fib`. 
  It’s possible to access `fib` from this place in code, because the list is lazy — the expression will not be evaluated 
  immediately when the lazy list is constructed, but only later, when `fib` already exists and we want to access one of its elements.
* `fib.zip(fib.tail)` takes two sequences, fib and its tail (i.e. fib without its first element), and zips them together into pairs. 
  The Fibonacci sequence is generated by summing each pair `(a, b) => a + b` of successive Fibonacci numbers.
* `take(10)` is used to fetch the first 10 Fibonacci numbers from the lazy list and `foreach(println)` prints them. 
  Note that the Fibonacci sequence is, in theory, infinite, but it doesn't cause any issues or out-of-memory errors 
  (at least not yet), thanks to the lazy evaluation.
* Alternatively, you can use `takeWhile` to compute consecutive elements of the lazy list until a certain requirement is fulfilled.
* Methods opposite to `take` and `takeWhile` — `drop` and `dropWhile` — can be used to compute and then ignore 
  a certain number of elements in the lazy list, or compute and ignore elements until a certain requirement is met. 
  You can chain them. 
  For example, `fib.drop(5).take(5)` will compute the first 10 elements of the Fibonacci sequence but will ignore the first 5 of them.

To learn more about methods of Scala `LazyList`, read its [documentation](https://www.scala-lang.org/api/current/scala/collection/immutable/LazyList.html).
